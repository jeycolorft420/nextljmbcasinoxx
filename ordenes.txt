Entiendo perfectamente. Vamos a dejar las sutilezas y aplicar **soluciones radicales** a nivel de arquitectura para forzar que el juego se comporte como quieres.

Aqu√≠ est√° el plan de choque:

1.  **Tiempo 30s (Radical):** El servidor mentir√° descaradamente. Le dir√° al cliente que la ronda empez√≥ **2 segundos en el futuro**. As√≠, por mucho lag que tengas, tu reloj siempre empezar√° "sobrado" y lo recortaremos visualmente a 30.
2.  **Cartel Blindado:** Vamos a separar el "Estado L√≥gico" del "Estado Visual". Aunque el servidor ya haya empezado la siguiente ronda, tu pantalla **se negar√° a actualizarse** hasta que termine de mostrar el cartel de victoria (4 segundos obligatorios).
3.  **Dados S√≥lidos (CSS Hack):** Haremos las caras de los dados un 1% m√°s grandes para que se superpongan entre ellas (`101%`), eliminando f√≠sicamente cualquier hueco visual.
4.  **Estabilidad de Puesto:** Usaremos "Memoria de Sesi√≥n" para que, aunque el internet parpadee, el juego nunca olvide cu√°l es tu silla (evitando que cambies de lugar con el bot).

-----

### 1\. üé® CSS: Arreglar "Dados Rotos" (Huecos)

Haremos que las caras se solapen ligeramente para sellar el cubo.

**Archivo:** `src/modules/games/dice/components/dice/ThreeDDice.css`
**Instrucci√≥n para Gravity:** Reemplaza todo el contenido con esto.

```css
.scene {
  display: flex;
  justify-content: center;
  align-items: center;
  perspective: 600px;
}

.cube {
  position: relative;
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;
  transition: transform 1s cubic-bezier(0.1, 0.9, 0.2, 1);
}

.cube__face {
  position: absolute;
  /* üö® FIX RADICAL: 102% para solapar bordes y tapar huecos */
  width: 102%;
  height: 102%;
  left: -1%; top: -1%; 
  
  background-color: var(--base-color, white);
  border-radius: 12%; /* Un poco menos redondo para cerrar esquinas */
  backface-visibility: hidden; /* Oculta el interior */
  box-shadow: inset 0 0 15px rgba(0,0,0,0.2);
  display: flex; 
  justify-content: center;
  align-items: center;
  border: 1px solid rgba(0,0,0,0.05); /* Borde sutil */
}

/* N√∫cleo oscuro para dar sensaci√≥n de masa si se ve un hueco */
.cube__inner {
  position: absolute;
  width: 98%; height: 98%;
  top: 1%; left: 1%;
  background: #0f172a;
  transform: translateZ(1px);
}

/* Transformaciones (Se mantienen igual, pero la geometr√≠a ahora es s√≥lida) */
.cube__face--1 { transform: rotateY(0deg) translateZ(var(--depth)); }
.cube__face--2 { transform: rotateY(90deg) translateZ(var(--depth)); }
.cube__face--3 { transform: rotateY(180deg) translateZ(var(--depth)); }
.cube__face--4 { transform: rotateY(-90deg) translateZ(var(--depth)); }
.cube__face--5 { transform: rotateX(90deg) translateZ(var(--depth)); }
.cube__face--6 { transform: rotateX(-90deg) translateZ(var(--depth)); }

@keyframes tumble {
  0% { transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg); }
  100% { transform: rotateX(720deg) rotateY(360deg) rotateZ(360deg); }
}

.is-rolling {
  animation: tumble 0.5s linear infinite;
}
```

-----

### 2\. ‚è≥ Backend: Inyecci√≥n de Tiempo "Futuro" (+2s)

Vamos a darle 2 segundos de ventaja al reloj.

**Instrucci√≥n para Gravity:**

1.  **En `src/modules/games/dice/lib/maintenance.ts`:**
    Busca todas las ocurrencias de `roundStartedAt: Date.now()`.
    **Reempl√°zalas por:** `roundStartedAt: Date.now() + 2000`. (Antes era +1000, ahora +2000 es radical).

2.  **En `src/app/api/rooms/[id]/roll/route.ts`:**
    Busca `roundStartedAt: Date.now()`.
    **Reempl√°zala por:** `roundStartedAt: Date.now() + 2000`.

-----

### 3\. üß† Frontend: Tablero Blindado (DiceBoard.tsx)

Esta es la correcci√≥n m√°s importante. Vamos a reescribir la l√≥gica para que:

1.  Use `Math.min(30, ...)` forzando el tope visual.
2.  **Bloquee actualizaciones** mientras muestra el ganador (`animationLock`).
3.  Recuerde tu posici√≥n para no intercambiarte con el bot.

**Archivo:** `src/modules/games/dice/components/dice/DiceBoard.tsx`
**Instrucci√≥n para Gravity:** Reemplaza el componente COMPLETO con esta versi√≥n "Blindada".

```tsx
"use client";

import { useEffect, useMemo, useRef, useState } from "react";
import { useRouter } from "next/navigation";
import DiceDuel from "@/modules/games/dice/components/DiceDuel";
import { type DiceSkin } from "./ThreeDDice";
import { toast } from "sonner";
import confetti from "canvas-confetti";
import { useAudio } from "@/context/AudioContext";

// ... (Types Entry y Room se mantienen igual) ...
type Entry = {
  id: string;
  position: number;
  user: { id: string; name: string | null; email: string; selectedDiceColor?: string | null };
};

type Room = {
  id: string;
  title: string;
  priceCents: number;
  state: "OPEN" | "LOCKED" | "FINISHED" | "DRAWING";
  capacity: number;
  prizeCents?: number | null;
  winningEntryId?: string | null;
  entries?: Entry[];
  gameMeta?: any | null;
  currentRound?: number;
};

// ... (DiceHistory se mantiene igual) ...
export function DiceHistory({ room, className = "", maxHeight = 220, swapVisuals = false }: { room: Room; className?: string; maxHeight?: number; swapVisuals?: boolean }) {
  // ... (Tu c√≥digo de historial existente) ...
  return null; // Simplificado para el ejemplo, usa tu c√≥digo anterior aqu√≠
}

type Props = {
  room: Room;
  userId: string | null;
  email?: string | null;
  onReroll: () => Promise<void>;
  onForfeit: () => Promise<void>;
  onLeave: () => Promise<void>;
  onRejoin: () => Promise<void>;
  onOpenHistory?: () => void;
  onAfterAnim?: () => void;
  wheelSize: number;
};

const fmtUSD = (c: number) => `$${(c / 100).toFixed(2)}`;
function toSkin(s?: string | null): DiceSkin {
  const allowed: DiceSkin[] = ["white", "green", "blue", "yellow", "red", "purple", "black"];
  return (s && (allowed as readonly string[]).includes(s)) ? (s as DiceSkin) : "white";
}

export default function DiceBoard({ room, userId, email, onLeave, onRejoin, onOpenHistory, wheelSize }: Props) {
  const router = useRouter();
  const { play } = useAudio();
  
  // 1. MEMORIA DE POSICI√ìN (Evita el "Seat Swap")
  const persistentPosition = useRef<number | null>(null);
  
  const meEntryRaw = room.entries?.find((e) => e.user.id === userId || (email && e.user.email === email)) ?? null;
  if (meEntryRaw && persistentPosition.current === null) {
      persistentPosition.current = meEntryRaw.position;
  }
  
  // Si tenemos posici√≥n guardada, la forzamos visualmente aunque la API falle un frame
  const amTop = persistentPosition.current === 1; 
  const swapVisuals = amTop; // Si soy el 1, me pongo abajo (swap)

  // Identificar Jugadores por Posici√≥n Fija
  const topEntry = room.entries?.find(e => e.position === 1);
  const bottomEntry = room.entries?.find(e => e.position === 2);

  // 2. ESTADO VISUAL BLINDADO
  const [visualWinner, setVisualWinner] = useState<any>(null);
  const [animationLock, setAnimationLock] = useState(false); // Bloqueo global de UI
  const [rolling, setRolling] = useState(false);
  
  // Detectar ganador real desde el servidor
  const serverWinner = useMemo(() => {
    const history = room.gameMeta?.history || [];
    if (!history.length) return null;
    const lastRound = history[history.length - 1];
    // Solo consideramos ganador si la ronda del historial coincide o es reciente
    return {
        name: !lastRound.winnerEntryId ? "Empate" : (room.entries?.find((e) => e.id === lastRound.winnerEntryId)?.user?.name || "Jugador"),
        amount: fmtUSD(lastRound.damage ?? 0),
        isTie: !lastRound.winnerEntryId,
        round: lastRound.round
    };
  }, [room.gameMeta?.history, room.entries]);

  // Sincronizaci√≥n de Cartel (RADICAL: Obliga a esperar)
  const lastProcessedRound = useRef<number>(0);

  useEffect(() => {
    if (serverWinner && serverWinner.round !== lastProcessedRound.current) {
        lastProcessedRound.current = serverWinner.round;
        setAnimationLock(true); // üîí BLOQUEAR INTERFAZ

        // Secuencia: Rodar (1.5s) -> Mostrar Ganador (4s) -> Desbloquear
        setTimeout(() => {
            setVisualWinner(serverWinner);
            if (room.state === "FINISHED") {
                play("win");
                confetti({ particleCount: 150, spread: 70, origin: { y: 0.6 } });
            }
            
            // Mantener cartel 4 segundos COMPLETOS
            setTimeout(() => {
                setVisualWinner(null);
                setAnimationLock(false); // üîì DESBLOQUEAR
                router.refresh();
            }, 4000);

        }, 1500); // Esperar a que los dados "paren" visualmente
    }
  }, [serverWinner, room.state, router, play]);


  // 3. TIMER RADICAL (Siempre 30s)
  const [timer, setTimer] = useState(30);
  const roundStartedAt = (room.gameMeta?.roundStartedAt as number) || 0;
  
  useEffect(() => {
    // Si hay bloqueo de animaci√≥n, no tocamos el timer (se queda en lo que estaba o 0)
    if (animationLock) return; 

    const tick = () => {
         if (!roundStartedAt) { 
             setTimer(30); 
             return; 
         }
         
         const now = Date.now();
         // El servidor nos da roundStartedAt en el FUTURO (+2000ms).
         // Si now < roundStartedAt, elapsed es negativo, perfecto para mantener 30s.
         const elapsed = (now - roundStartedAt) / 1000;
         
         // Si elapsed es -2, -1, 0, 0.5... visualTime ser√° > 30.
         // Math.min(30) lo clava en 30.
         const visualTime = Math.min(30, Math.floor(30 - elapsed));
         
         setTimer(Math.max(0, visualTime));
    };
    
    // Ejecutar inmediatamente y luego en intervalo
    tick();
    const t = setInterval(tick, 1000);
    return () => clearInterval(t);
  }, [roundStartedAt, animationLock]);


  // 4. L√ìGICA DE DADOS Y ANIMACI√ìN
  const rolls = room.gameMeta?.rolls || {};
  const lastDice = room.gameMeta?.lastDice || {};

  const activeTop = topEntry ? rolls[topEntry.user.id] : null;
  const activeBottom = bottomEntry ? rolls[bottomEntry.user.id] : null;

  // Si hay bloqueo, mostramos los dados "finales" (lastDice)
  // Si no, mostramos los dados activos
  const currentTopRoll = animationLock ? lastDice.top : (activeTop || lastDice.top);
  const currentBottomRoll = animationLock ? lastDice.bottom : (activeBottom || lastDice.bottom);

  // Animaci√≥n del oponente
  const [opponentRolling, setOpponentRolling] = useState(false);
  const prevOppRoll = useRef("");
  const opRollData = swapVisuals ? activeBottom : activeTop; // El oponente es el "otro"

  useEffect(() => {
    const s = JSON.stringify(opRollData);
    if (s !== prevOppRoll.current && opRollData && !animationLock) {
        play("roll");
        setOpponentRolling(true);
        setTimeout(() => setOpponentRolling(false), 800);
    }
    prevOppRoll.current = s;
  }, [opRollData, animationLock, play]);


  // 5. STATUS TEXT (Limpio)
  let statusText = "";
  let myTurn = false;

  if (room.state === "FINISHED") statusText = "Juego Terminado";
  else if (animationLock || visualWinner) statusText = ""; // ü§´ Silencio durante animaci√≥n
  else {
      // L√≥gica de turno est√°ndar
      const starterId = room.gameMeta?.nextStarterUserId || topEntry?.user.id;
      const isTopStarter = topEntry?.user.id === starterId;
      const hasRolledTop = !!rolls[topEntry?.user.id || ""];
      const hasRolledBottom = !!rolls[bottomEntry?.user.id || ""];
      
      let turnId = null;
      if (isTopStarter) turnId = !hasRolledTop ? topEntry?.user.id : bottomEntry?.user.id;
      else turnId = !hasRolledBottom ? bottomEntry?.user.id : topEntry?.user.id;

      if (turnId) {
          myTurn = meEntryRaw?.user.id === turnId;
          statusText = myTurn ? "¬°TU TURNO!" : "Esperando al oponente...";
      }
  }

  // ACCI√ìN DE TIRAR
  const handleRoll = async () => {
    if (rolling || animationLock) return;
    setRolling(true);
    play("roll");
    try {
      await fetch(`/api/rooms/${room.id}/roll`, { method: "POST" });
      router.refresh();
    } catch { toast.error("Error"); }
    finally { setTimeout(() => setRolling(false), 500); }
  };
  
  // Heartbeat para despertar bots
  useEffect(() => {
     if (!myTurn && !animationLock && room.state === "OPEN") {
         const t = setInterval(() => router.refresh(), 3000);
         return () => clearInterval(t);
     }
  }, [myTurn, animationLock, room.state, router]);

  // SKINS
  const lastTopSkin = useRef<DiceSkin>("white");
  const lastBottomSkin = useRef<DiceSkin>("white");
  if (topEntry?.user.selectedDiceColor) lastTopSkin.current = toSkin(topEntry.user.selectedDiceColor);
  if (bottomEntry?.user.selectedDiceColor) lastBottomSkin.current = toSkin(bottomEntry.user.selectedDiceColor);

  return (
    <div className="relative flex flex-col items-center">
      <div className="w-full mx-auto relative" style={{ maxWidth: wheelSize }}>
        <DiceDuel
          // VISUALES SWAP (Para que siempre est√©s abajo)
          topRoll={swapVisuals ? currentBottomRoll : currentTopRoll}
          bottomRoll={swapVisuals ? currentTopRoll : currentBottomRoll}
          
          isRollingTop={swapVisuals ? rolling : opponentRolling} 
          isRollingBottom={swapVisuals ? opponentRolling : rolling}
          
          // Ghost: Solo mostramos fantasmas si NO hay animaci√≥n bloqueante
          isGhostTop={!animationLock && (swapVisuals ? !activeBottom : !activeTop)}
          isGhostBottom={!animationLock && (swapVisuals ? !activeTop : !activeBottom)}

          statusText={statusText}
          winnerDisplay={visualWinner} // Usamos el ganador "Delayed"

          onRoll={handleRoll}
          canRoll={myTurn && !rolling && !animationLock}
          timeLeft={myTurn && !animationLock ? timer : undefined} // Ocultar timer en animaci√≥n

          onExit={onLeave}
          onRejoin={onRejoin}
          isFinished={room.state === "FINISHED"}
          onOpenHistory={onOpenHistory}

          labelTop={(swapVisuals ? bottomEntry?.user.name : topEntry?.user.name) || "J1"}
          labelBottom={(swapVisuals ? topEntry?.user.name : bottomEntry?.user.name) || "T√∫"}
          
          diceColorTop={swapVisuals ? lastBottomSkin.current : lastTopSkin.current}
          diceColorBottom={swapVisuals ? lastTopSkin.current : lastBottomSkin.current}

          balanceTop={fmtUSD(room.gameMeta?.balances?.[swapVisuals ? bottomEntry?.user.id! : topEntry?.user.id!] ?? room.priceCents)}
          balanceBottom={fmtUSD(room.gameMeta?.balances?.[swapVisuals ? topEntry?.user.id! : bottomEntry?.user.id!] ?? room.priceCents)}
        />
      </div>
    </div>
  );
}
```

-----

### 4\. üö´ Fix: Bot√≥n de Compra (BuySeatUI.tsx)

Evitar que salga "Comprar Puesto" si ya hay gente o est√° activo.

**Archivo:** `src/modules/rooms/components/BuySeatUI.tsx`
**Instrucci√≥n:**

```typescript
// Al inicio del componente
if (room.state !== "OPEN" || room.entries.length >= 2) return null;
```

**Resumen:**

1.  **Dados S√≥lidos:** CSS `102%`.
2.  **Tiempo 30s:** Backend `+2000ms`, Frontend `Math.min(30)`.
3.  **Sin Lag Visual:** `animationLock` fuerza una pausa de 4s para ver el ganador antes de cambiar a "Waiting".
4.  **Posici√≥n Fija:** `persistentPosition` evita el baile de sillas.