He analizado a fondo los problemas que mencionas. Tienes toda la razÃ³n: para que el juego se sienta **100% profesional y confiable**, no pueden haber discrepancias de tiempo, ni carteles que salen antes de tiempo, ni dados que parecen "huecos".

He preparado un paquete de correcciones de **Alta PrecisiÃ³n** para solucionar estos 4 puntos crÃ­ticos:

1.  **Tiempo Robado (29s):** Implementaremos un "Buffer de Servidor". El servidor configurarÃ¡ el inicio de la ronda **1 segundo en el futuro**. AsÃ­, cuando el mensaje llegue a tu navegador, el reloj estarÃ¡ exactamente en 30s (o 31s ocultos que se ven como 30s).
2.  **Cartel Prematuro:** El navegador esperarÃ¡ obligatoriamente a que termine la animaciÃ³n de los dados (2 segundos) antes de mostrar quiÃ©n ganÃ³.
3.  **Dados Huecos:** Agregaremos un "NÃºcleo" (Core) dentro del dado 3D mediante CSS para que parezca un bloque sÃ³lido y no lÃ¡minas de papel.
4.  **Popup "Comprar Puesto":** Bloquearemos el renderizado de este botÃ³n si el usuario ya es parte de la sala (`meEntry`).

AquÃ­ tienes las instrucciones para Gravity.

-----

### 1\. ğŸ›¡ï¸ Backend: Buffer de Tiempo (Anti-Lag)

Vamos a hacer que el servidor sea "generoso" y regale 1000ms al iniciar el reloj.

**InstrucciÃ³n para Gravity (Copia y Pega):**

> "Gravity, necesito ajustar la sincronizaciÃ³n de tiempo en el servidor para compensar el lag de red.
>
> 1.  **En `src/modules/games/dice/lib/maintenance.ts`:**
>     Busca todas las lÃ­neas donde haces `roundStartedAt: Date.now()`.
>     CÃ¡mbialas por: `roundStartedAt: Date.now() + 1000` (Sumar 1 segundo).
>     *Esto aplica tanto al iniciar la primera ronda como al reiniciar el reloj tras una resoluciÃ³n.*
>
> 2.  **En `src/app/api/rooms/[id]/roll/route.ts`:**
>     Busca la lÃ­nea: `roundStartedAt: Date.now()`.
>     CÃ¡mbiala por: `roundStartedAt: Date.now() + 1000`.
>
> Esto harÃ¡ que el cliente reciba el tiempo 'en el futuro', garantizando que el contador empiece en 30s clavados."

-----

### 2\. ğŸ§Š Frontend: Dados SÃ³lidos y Banner Sincronizado

Vamos a rediseÃ±ar el componente del dado para rellenar su interior y mejorar la lÃ³gica del tablero para esperar la animaciÃ³n.

**InstrucciÃ³n para Gravity (Copia y Pega):**

> "Gravity, actualiza los componentes visuales para mejorar la calidad y la sincronizaciÃ³n.
>
> **A. En `src/modules/games/dice/components/dice/ThreeDDice.css`:**
> Agrega este estilo para crear un nÃºcleo sÃ³lido dentro del dado y evitar que se vea hueco:
>
> ```css
> /* NÃºcleo sÃ³lido para evitar ver a travÃ©s */
> .cube__inner {
>   position: absolute;
>   width: 98%;
>   height: 98%;
>   top: 1%; left: 1%;
>   background: black; /* O el color oscuro que prefieras para el interior */
>   transform: translateZ(1px); /* PequeÃ±o ajuste */
>   box-shadow: 0 0 20px rgba(0,0,0,0.5);
>   opacity: 0.9;
> }
> ```
>
> *Nota: AsegÃºrate de que las caras `.cube__face` tengan `backface-visibility: hidden;`.*
>
> **B. En `src/modules/games/dice/components/dice/ThreeDDice.tsx`:**
> Agrega el div del nÃºcleo dentro del componente `.cube`:
>
> ```tsx
>       <div className={`cube ...`}>
>         <div className="cube__inner" style={{ transform: `translateZ(-2px)` }}></div> 
>         {/* ... (el map de las caras sigue aquÃ­) */}
> ```
>
> **C. En `src/modules/games/dice/components/dice/DiceBoard.tsx` (LÃ³gica de Banner):**
> Actualmente muestras `winnerDisplay` directamente. ModifÃ­calo para usar un estado intermedio `delayedWinner` que espere a que los dados dejen de rodar.
>
> Reemplaza la lÃ³gica del renderizado del banner:
>
> ```typescript
>   // Estado para retrasar el cartel hasta que termine la animaciÃ³n
>   const [delayedWinner, setDelayedWinner] = useState<any>(null);
> ```

> useEffect(() =\> {
> if (winnerDisplay) {
> // Si hay ganador, esperar 1.5s (tiempo de giro) antes de mostrarlo
> const t = setTimeout(() =\> setDelayedWinner(winnerDisplay), 1500);
> return () =\> clearTimeout(t);
> } else {
> setDelayedWinner(null);
> }
> }, [winnerDisplay]);
>
> ```
> 
> Y en el JSX, pasa `delayedWinner` al componente `DiceDuel` en lugar de `winnerDisplay`.

> **D. Ocultar BotÃ³n de Compra (`BuySeatUI`):**
> En `DiceBoard.tsx`, si `meEntry` existe (el usuario ya estÃ¡ jugando), asegÃºrate de no renderizar ningÃºn componente de compra de asientos."
> ```

-----

### ExplicaciÃ³n de las Mejoras

1.  **Tiempo 30s:** Al sumar `+1000ms` en el servidor, si el mensaje tarda 200ms en llegar a tu casa, el cÃ¡lculo serÃ¡:
    `30 - (HoraActual - (HoraInicio + 1000))`.
    MatemÃ¡ticamente, el reloj de tu navegador pensarÃ¡ que faltan **30.8 segundos**.
    Como tu cÃ³digo tiene `Math.min(30, ...)`, se quedarÃ¡ clavado en **30** durante casi un segundo antes de bajar a 29. **SensaciÃ³n perfecta.**
2.  **SincronizaciÃ³n:** El `setTimeout` de 1500ms en `DiceBoard` asegura que primero veas rodar los dados, se detengan, y *luego* (Â¡Boom\!) salga el cartel de "Ganaste". Genera suspenso y confianza.
3.  **Dados SÃ³lidos:** El `.cube__inner` es un truco visual (un cubo negro o del color del dado ligeramente mÃ¡s pequeÃ±o adentro) que tapa los huecos entre las aristas. Ya no parecerÃ¡n hojas de papel.

Con estos ajustes, el juego se verÃ¡ y sentirÃ¡ **sÃ³lido como una roca**. ğŸ²ğŸš€