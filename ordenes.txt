Es evidente que al intentar migrar o mezclar l贸gicas, se rompi贸 la comunicaci贸n entre lo que el servidor "piensa" y lo que el cliente "ve". El c贸digo actual del servidor (`DiceRoom.ts` que subiste) tiene una l贸gica h铆brida extra帽a ("LOCKED", "ready", tiros simult谩neos) que choca con la idea de un juego por turnos fluido.

Para arreglar esto **definitivamente** en tu entorno Antigravity, vamos a alinear los dos mundos. Te voy a dar el c贸digo "limpio" y simplificado del Backend (para que gestione turnos reales) y, muy importante, el c贸digo del Frontend (`DiceBoard.tsx`) para que entienda esa nueva l贸gica.

Copia y pega estos archivos en orden.

### 1\. El Cerebro del Juego (Backend)

Este archivo define las reglas: turnos secuenciales, bots autom谩ticos y robo de saldo. Elimina toda la complejidad innecesaria de "slots" y "ready".

**Archivo:** `game-server/src/DiceRoom.ts`

```typescript
import { Server, Socket } from 'socket.io';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// --- CONFIGURACIN ---
const PERCENTAGE_PER_ROUND = 0.20; // 20% de la apuesta total inicial
const TURN_TIMEOUT = 12000;        // 12 segundos para tirar (humanos)

interface Player {
    socketId: string;
    userId: string;
    username: string;
    avatarUrl: string;
    position: 1 | 2;
    balance: number;     // Saldo en juego (centavos)
    skin: string;
    isBot: boolean;
    connected: boolean;
}

export class DiceRoom {
    public id: string;
    public priceCents: number;
    public stepValue: number;
    
    // Configuraci贸n de tiempos
    public botWaitMs: number;
    public autoLockAt: Date | null;

    public players: Player[] = [];
    public status: 'WAITING' | 'PLAYING' | 'FINISHED' = 'WAITING';
    
    // Estado de la ronda
    public round: number = 1;
    public turnUserId: string | null = null;
    public rolls: { [userId: string]: [number, number] } = {}; // { "user1": [4, 2] }
    
    private io: Server;
    private timer: NodeJS.Timeout | null = null;
    private botTimer: NodeJS.Timeout | null = null;

    constructor(roomId: string, priceCents: number, botWaitMs: number, autoLockAt: Date | null, io: Server) {
        this.id = roomId;
        this.priceCents = priceCents;
        // Calculamos cu谩nto se roba por ronda (20% de la apuesta de UN jugador)
        this.stepValue = Math.floor(this.priceCents * PERCENTAGE_PER_ROUND); 
        this.botWaitMs = botWaitMs;
        this.autoLockAt = autoLockAt;
        this.io = io;

        this.initAutoClose();
    }

    // --- GESTIN DE JUGADORES ---

    public addPlayer(socket: Socket, user: any, isBot: boolean = false) {
        // 1. Reconexi贸n
        const existing = this.players.find(p => p.userId === user.id);
        if (existing) {
            if (!isBot) existing.socketId = socket.id;
            existing.connected = true;
            this.emitState();
            return;
        }

        if (this.players.length >= 2 || (this.status !== 'WAITING' && !isBot)) return;

        // 2. Nuevo Jugador
        const position = this.players.some(p => p.position === 1) ? 2 : 1;
        
        this.players.push({
            socketId: isBot ? 'bot' : socket.id,
            userId: user.id,
            username: user.name || "Jugador",
            avatarUrl: user.avatar || "",
            position,
            balance: this.priceCents, // Empiezan con su apuesta
            skin: user.selectedDiceColor || 'white',
            isBot,
            connected: true
        });

        // Ordenar para consistencia visual (P1 siempre izquierda/arriba)
        this.players.sort((a, b) => a.position - b.position);

        this.emitState();

        // 3. L贸gica de Inicio
        if (this.players.length === 1) {
            this.scheduleBot();
        } else if (this.players.length === 2) {
            this.cancelBot();
            setTimeout(() => this.startGame(), 1000); // 1s delay para ver al oponente entrar
        }
    }

    public removePlayer(socketId: string) {
        const p = this.players.find(p => p.socketId === socketId);
        if (!p) return;

        if (this.status === 'WAITING') {
            // Si no ha empezado, se va del todo
            this.players = this.players.filter(pl => pl.socketId !== socketId);
            this.scheduleBot(); // Reiniciar timer de bot si queda solo 1
        } else {
            // Si ya empez贸, solo desconectado
            p.connected = false;
        }
        this.emitState();
    }

    // --- LGICA DE JUEGO ---

    private startGame() {
        this.status = 'PLAYING';
        this.round = 1;
        this.rolls = {};
        // Empieza el Jugador 1 (Host)
        const p1 = this.players.find(p => p.position === 1);
        this.turnUserId = p1 ? p1.userId : this.players[0].userId;
        
        this.emitState();
        this.processTurn();
    }

    public handleRoll(userId: string) {
        if (this.status !== 'PLAYING') return;
        if (this.turnUserId !== userId) return;
        if (this.rolls[userId]) return; // Ya tir贸

        // Generar Dados
        const d1 = Math.ceil(Math.random() * 6);
        const d2 = Math.ceil(Math.random() * 6);
        this.rolls[userId] = [d1, d2];

        // Emitir Evento de Tiro (Animaci贸n)
        this.io.to(this.id).emit('dice_anim', { userId, result: [d1, d2] });
        
        // Siguiente paso
        this.nextTurnOrResult(userId);
    }

    private nextTurnOrResult(justRolledId: string) {
        // Pausa dram谩tica para ver los dados (1.5s)
        if (this.timer) clearTimeout(this.timer);

        setTimeout(() => {
            const opponent = this.players.find(p => p.userId !== justRolledId);
            
            if (opponent && !this.rolls[opponent.userId]) {
                // Falta el oponente -> Cambio de Turno
                this.turnUserId = opponent.userId;
                this.emitState();
                this.processTurn();
            } else {
                // Ambos tiraron -> Resultado
                this.resolveRound();
            }
        }, 1200); 
    }

    private resolveRound() {
        const p1 = this.players[0];
        const p2 = this.players[1];
        
        const sum1 = this.rolls[p1.userId][0] + this.rolls[p1.userId][1];
        const sum2 = this.rolls[p2.userId][0] + this.rolls[p2.userId][1];

        let winnerId: string | null = null;

        if (sum1 > sum2) {
            winnerId = p1.userId;
            p1.balance += this.stepValue;
            p2.balance -= this.stepValue;
        } else if (sum2 > sum1) {
            winnerId = p2.userId;
            p2.balance += this.stepValue;
            p1.balance -= this.stepValue;
        } 
        // Empate = nadie gana nada

        // Clamp balances
        if (p1.balance < 0) p1.balance = 0;
        if (p2.balance < 0) p2.balance = 0;

        // Emitir Resultado
        this.io.to(this.id).emit('round_result', {
            winnerId,
            rolls: this.rolls,
            balances: { [p1.userId]: p1.balance, [p2.userId]: p2.balance }
        });

        // Check Game Over
        const loser = this.players.find(p => p.balance <= 0);
        if (loser) {
            const winner = this.players.find(p => p.userId !== loser.userId);
            setTimeout(() => this.finishGame(winner!), 2000);
        } else {
            setTimeout(() => this.startNextRound(), 3000);
        }
    }

    private startNextRound() {
        this.round++;
        this.rolls = {};
        // Alternar turno inicial o mantener en P1 (Simplifiquemos: P1 empieza)
        const p1 = this.players.find(p => p.position === 1);
        this.turnUserId = p1?.userId || null;
        
        this.emitState();
        this.processTurn();
    }

    private async finishGame(winner: Player) {
        this.status = 'FINISHED';
        this.turnUserId = null;
        const totalPot = this.players.reduce((a, b) => a + this.priceCents, 0); // Suma de entradas iniciales

        this.io.to(this.id).emit('game_over', { 
            winnerId: winner.userId,
            prize: totalPot 
        });
        
        this.emitState();

        // Persistencia
        try {
            // 1. Guardar resultado
            await prisma.gameResult.create({
                data: {
                    roomId: this.id,
                    winnerUserId: winner.userId,
                    winnerName: winner.username,
                    prizeCents: totalPot,
                    roundNumber: this.round
                }
            });
            // 2. Dar dinero
            await prisma.user.update({
                where: { id: winner.userId },
                data: { balanceCents: { increment: totalPot } }
            });
            // 3. Cerrar sala
            await prisma.room.update({
                where: { id: this.id },
                data: { state: 'FINISHED', finishedAt: new Date(), winningEntryId: winner.userId }
            });
        } catch(e) { console.error("DB Error", e); }
    }

    // --- UTILIDADES ---

    private processTurn() {
        if (this.timer) clearTimeout(this.timer);
        
        const currentPlayer = this.players.find(p => p.userId === this.turnUserId);
        if (!currentPlayer) return;

        if (currentPlayer.isBot) {
            // Bot tira r谩pido (1-2s)
            this.timer = setTimeout(() => {
                this.handleRoll(currentPlayer.userId);
            }, Math.random() * 1000 + 1000);
        } else {
            // Humano tiene tiempo l铆mite
            this.timer = setTimeout(() => {
                // Auto-roll si se duerme
                this.handleRoll(currentPlayer.userId);
            }, TURN_TIMEOUT);
        }
    }

    private scheduleBot() {
        if (this.botTimer) clearTimeout(this.botTimer);
        if (this.botWaitMs > 0 && this.players.length === 1) {
            this.botTimer = setTimeout(() => {
                this.injectBot();
            }, this.botWaitMs);
        }
    }

    private cancelBot() {
        if (this.botTimer) { clearTimeout(this.botTimer); this.botTimer = null; }
    }

    private async injectBot() {
        try {
            const bot = await prisma.user.findFirst({ where: { isBot: true } });
            if (bot) {
                this.addPlayer({ id: 'bot-sock' } as any, { // Mock socket
                    id: bot.id,
                    name: bot.name || 'Bot',
                    avatar: bot.avatarUrl,
                    selectedDiceColor: bot.selectedDiceColor
                }, true);
            }
        } catch(e) {}
    }

    private initAutoClose() {
        // L贸gica opcional para cerrar sala vac铆a
        if (this.autoLockAt) {
            const diff = this.autoLockAt.getTime() - Date.now();
            setTimeout(() => {
                if (this.status === 'WAITING' && this.players.length < 2) {
                    this.io.to(this.id).emit('room_closed');
                    // update db...
                }
            }, diff);
        }
    }

    private emitState() {
        this.io.to(this.id).emit('update_game', {
            status: this.status,
            round: this.round,
            turnUserId: this.turnUserId,
            rolls: this.rolls,
            players: this.players.map(p => ({
                userId: p.userId,
                name: p.username,
                avatar: p.avatarUrl,
                balance: p.balance,
                position: p.position,
                isBot: p.isBot,
                skin: p.skin,
                connected: p.connected
            }))
        });
    }
}
```

### 2\. El Conector Visual (Frontend)

Este es el archivo que recibe la l贸gica del servidor y le dice al componente visual (`DiceDuel.tsx`) qu茅 pintar. Reemplaza el contenido de `DiceBoard.tsx` (o donde tengas la l贸gica de conexi贸n del cliente).

**Archivo:** `src/modules/games/dice/components/dice/DiceBoard.tsx`

```tsx
"use client";

import { useEffect, useState, useRef } from "react";
import { io, Socket } from "socket.io-client";
import { toast } from "sonner";
import DiceDuel from "../DiceDuel"; // Aseg煤rate de que la ruta sea correcta
import { useSession } from "next-auth/react";

// URL de tu Game Server (Ajusta si es diferente en producci贸n)
const GAME_SERVER_URL = process.env.NEXT_PUBLIC_GAME_SERVER_URL || "http://localhost:4000";

interface Player {
  userId: string;
  name: string;
  avatar: string;
  balance: number;
  position: 1 | 2;
  isBot: boolean;
  skin: string;
}

interface GameState {
  status: "WAITING" | "PLAYING" | "FINISHED";
  round: number;
  turnUserId: string | null;
  rolls: { [key: string]: [number, number] };
  players: Player[];
  winnerId?: string;
}

export default function DiceBoard({ roomId, user }: { roomId: string; user: any }) {
  const socketRef = useRef<Socket | null>(null);
  const [gameState, setGameState] = useState<GameState | null>(null);
  
  // Estados visuales locales
  const [isRolling, setIsRolling] = useState(false);
  const [animRolls, setAnimRolls] = useState<{ [key: string]: boolean }>({});

  useEffect(() => {
    // 1. Conexi贸n
    const socket = io(GAME_SERVER_URL, {
      transports: ["websocket"],
      reconnectionAttempts: 5,
    });
    socketRef.current = socket;

    socket.on("connect", () => {
      console.log(" Conectado al Game Server");
      // Unirse a la sala con datos del usuario
      socket.emit("join_room", { 
        roomId, 
        user: { 
            id: user.id, 
            name: user.name, 
            avatar: user.image,
            selectedDiceColor: user.selectedDiceColor // Si tienes esto en sesi贸n
        } 
      });
    });

    // 2. Escuchar Actualizaciones de Estado
    socket.on("update_game", (state: GameState) => {
      console.log(" Update:", state);
      setGameState(state);
      
      // Limpiar animaciones si cambi贸 el turno
      if (state.turnUserId) {
         setAnimRolls(prev => ({ ...prev, [state.turnUserId!]: false }));
      }
    });

    // 3. Animaci贸n de Tiro (Evento espec铆fico)
    socket.on("dice_anim", ({ userId, result }: { userId: string, result: [number, number] }) => {
      // Activar flag de rodando para ese usuario
      setAnimRolls(prev => ({ ...prev, [userId]: true }));
      
      // Sonido
      const audio = new Audio("/sfx/dice-roll.mp3");
      audio.play().catch(() => {});

      // Desactivar animaci贸n tras 1s (y el estado update_game traer谩 el resultado final)
      setTimeout(() => {
          setAnimRolls(prev => ({ ...prev, [userId]: false }));
      }, 1000);
    });

    socket.on("game_over", ({ winnerId, prize }) => {
       if (winnerId === user.id) {
           toast.success(`隆Ganaste $${(prize/100).toFixed(2)}!`);
           new Audio("/sfx/win.mp3").play().catch(()=>{});
       } else {
           toast.error("Has perdido esta vez.");
       }
    });

    socket.on("error", (err) => toast.error(err.message));

    return () => {
      socket.disconnect();
    };
  }, [roomId, user]);

  // --- LGICA DE RENDERIZADO ---

  if (!gameState) return <div className="text-white text-center mt-20">Cargando sala...</div>;

  const myPos = gameState.players.find(p => p.userId === user.id)?.position || 2;
  // Ordenamos para que "Yo" (bottom) sea siempre mi usuario, y "Oponente" (top) el otro
  const me = gameState.players.find(p => p.userId === user.id);
  const opponent = gameState.players.find(p => p.userId !== user.id);

  // Mapeo para DiceDuel.tsx
  // Si no hay oponente (esperando), pasamos null/ghost
  
  const isMyTurn = gameState.status === 'PLAYING' && gameState.turnUserId === user.id;
  
  // Calcular props para componente visual
  const topRoll = opponent ? gameState.rolls[opponent.userId] : null;
  const bottomRoll = me ? gameState.rolls[me.userId] : null;

  return (
    <div className="w-full h-full bg-[#050505] flex flex-col items-center justify-center">
      <DiceDuel
        // Datos Oponente (Top)
        labelTop={opponent?.name || "Esperando..."}
        balanceTop={opponent ? `$${(opponent.balance / 100).toFixed(2)}` : "---"}
        diceColorTop={opponent?.skin as any || "white"}
        topRoll={topRoll}
        isRollingTop={opponent ? animRolls[opponent.userId] : false}
        isGhostTop={!opponent} // Mostrar fantasma si no hay nadie

        // Datos M铆os (Bottom)
        labelBottom={me?.name || "T煤"}
        balanceBottom={me ? `$${(me.balance / 100).toFixed(2)}` : "---"}
        diceColorBottom={me?.skin as any || "white"}
        bottomRoll={bottomRoll}
        isRollingBottom={me ? animRolls[me.userId] : false}
        isGhostBottom={false}

        // Estado Global
        statusText={
            gameState.status === 'WAITING' ? "Esperando Oponente..." :
            gameState.status === 'FINISHED' ? "Partida Terminada" :
            isMyTurn ? "隆Tu Turno!" : `Turno de ${opponent?.name || "Rival"}`
        }
        
        // Controles
        canRoll={isMyTurn && !animRolls[user.id]} // Solo puedo tirar si es mi turno y no estoy ya rodando
        onRoll={() => {
            if (socketRef.current && isMyTurn) {
                socketRef.current.emit("roll_dice", { roomId });
            }
        }}
        
        // Timer (Opcional, si quieres mostrar cuenta atr谩s)
        timeLeft={isMyTurn ? 12 : undefined} 
        onExit={() => window.location.href = '/rooms'}
      />
    </div>
  );
}
```

### 3\. El Router del Servidor (Backend `index.ts`)

Aseg煤rate que tu servidor usa el nuevo mapa de seguridad que discutimos para que nadie pueda hackear los turnos.

**Archivo:** `game-server/src/index.ts`

```typescript
import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';
import cors from 'cors';
import { PrismaClient } from '@prisma/client';
import { DiceRoom } from './DiceRoom';

const prisma = new PrismaClient();
const app = express();
app.use(cors());

const httpServer = createServer(app);
const io = new Server(httpServer, {
    cors: { origin: "*", methods: ["GET", "POST"] }
});

const rooms: { [key: string]: DiceRoom } = {};
const socketToRoom: { [key: string]: string } = {};
const socketToUser: { [key: string]: string } = {};

io.on('connection', (socket) => {
    
    socket.on('join_room', async ({ roomId, user }) => {
        try {
            // Validar existencia
            const dbRoom = await prisma.room.findUnique({ where: { id: roomId } });
            if (!dbRoom) {
                socket.emit('error', { message: 'Sala no existe' });
                return;
            }

            // Mapeos
            socket.join(roomId);
            socketToRoom[socket.id] = roomId;
            socketToUser[socket.id] = user.id;

            // Instanciar
            if (!rooms[roomId]) {
                rooms[roomId] = new DiceRoom(
                    roomId, 
                    Number(dbRoom.priceCents), 
                    dbRoom.botWaitMs || 0,
                    dbRoom.autoLockAt || null, 
                    io
                );
            }
            
            // A帽adir jugador
            const dbUser = await prisma.user.findUnique({ where: { id: user.id } });
            rooms[roomId].addPlayer(socket, {
                ...user,
                // Usamos skin de DB o el que manda el front, preferencia DB
                selectedDiceColor: dbUser?.selectedDiceColor || user.selectedDiceColor
            });

        } catch (e) {
            console.error(e);
        }
    });

    socket.on('roll_dice', ({ roomId }) => {
        const room = rooms[roomId];
        const userId = socketToUser[socket.id];
        if (room && userId) {
            room.handleRoll(userId);
        }
    });

    socket.on('disconnect', () => {
        const roomId = socketToRoom[socket.id];
        if (roomId && rooms[roomId]) {
            rooms[roomId].removePlayer(socket.id);
            // Limpiar si vac铆a
            if (rooms[roomId].players.length === 0 && rooms[roomId].status !== 'PLAYING') {
                delete rooms[roomId];
            }
        }
        delete socketToRoom[socket.id];
        delete socketToUser[socket.id];
    });
});

const PORT = process.env.PORT || 4000;
httpServer.listen(PORT, () => {
    console.log(` Game Server Ready on ${PORT}`);
});
```

### 驴Qu茅 soluciona esto?

1.  **L贸gica Clara:** Ahora tienes `WAITING` -\> entra jugador -\> `WAITING` -\> entra bot/jugador -\> `PLAYING`. Sin estados intermedios confusos.
2.  **Turnos:** `DiceRoom` controla `turnUserId`. Si no es tu turno, `handleRoll` te ignora.
3.  **Visualizaci贸n:** El frontend ahora reacciona a `dice_anim` para rodar los dados visualmente, y luego a `update_game` para mostrar el resultado real. Esto recupera la fluidez que sent铆as perdida.