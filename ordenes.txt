Aqu√≠ tienes las instrucciones **definitivas y completas** para pasarle a Gravity.

Este mensaje recopila **todas** las soluciones radicales que hemos discutido: los dados s√≥lidos, el tiempo de 30s "forzado", la l√≥gica de bots "sombra" (que no se quedan solos) y el arreglo de los carteles.

Copia y pega todo lo que est√° entre las l√≠neas a continuaci√≥n y env√≠aselo.

-----

**GRAVITY, REALIZA ESTA ACTUALIZACI√ìN CR√çTICA (NIVEL: "FIX RADICAL").**

Tenemos 4 problemas persistentes que requieren una soluci√≥n agresiva de arquitectura:

1.  **Lag Visual:** El timer a veces muestra 29s/28s.
2.  **Bots:** Entran demasiado r√°pido, se quedan solos en la sala o roban los colores del jugador.
3.  **Visuales:** Los dados parecen huecos ("hojas de papel") y el cartel de ganador sale antes de tiempo.
4.  **UI:** El bot√≥n de "Comprar Puesto" sale en medio de la partida.

Aplica los siguientes cambios archivo por archivo:

### 1\. `src/modules/games/dice/components/dice/ThreeDDice.css` (Dados S√≥lidos)

Reemplaza todo el contenido. Usaremos un hack de `width: 102%` y un n√∫cleo oscuro para que los dados parezcan bloques s√≥lidos.

```css
.scene {
  display: flex;
  justify-content: center;
  align-items: center;
  perspective: 600px;
}

.cube {
  position: relative;
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;
  transition: transform 1s cubic-bezier(0.1, 0.9, 0.2, 1);
}

.cube__face {
  position: absolute;
  /* üö® FIX: 102% tapa las l√≠neas blancas de las aristas */
  width: 102%;
  height: 102%;
  left: -1%; top: -1%; 
  background-color: var(--base-color, white);
  border-radius: 12%; 
  backface-visibility: hidden;
  box-shadow: inset 0 0 15px rgba(0,0,0,0.2);
  display: flex; 
  justify-content: center;
  align-items: center;
  border: 1px solid rgba(0,0,0,0.05);
}

/* N√∫cleo oscuro para dar sensaci√≥n de masa */
.cube__inner {
  position: absolute;
  width: 98%; height: 98%;
  top: 1%; left: 1%;
  background: #0f172a;
  transform: translateZ(1px);
}

.cube__face--1 { transform: rotateY(0deg) translateZ(var(--depth)); }
.cube__face--2 { transform: rotateY(90deg) translateZ(var(--depth)); }
.cube__face--3 { transform: rotateY(180deg) translateZ(var(--depth)); }
.cube__face--4 { transform: rotateY(-90deg) translateZ(var(--depth)); }
.cube__face--5 { transform: rotateX(90deg) translateZ(var(--depth)); }
.cube__face--6 { transform: rotateX(-90deg) translateZ(var(--depth)); }

@keyframes tumble {
  0% { transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg); }
  100% { transform: rotateX(720deg) rotateY(360deg) rotateZ(360deg); }
}

.is-rolling {
  animation: tumble 0.5s linear infinite;
}
```

### 2\. `src/modules/games/dice/lib/maintenance.ts` (L√≥gica de Bots y Tiempo)

Reemplaza la funci√≥n `maintenanceDiceDuel` (o edita las secciones clave) para:

1.  **Inyectar Tiempo Futuro:** Sumar +2000ms al iniciar y +5000ms al reiniciar ronda.
2.  **Shadow Bot:** El bot se borra si est√° solo.

**Bloque de Resoluci√≥n de Ronda (Buscar y reemplazar):**

```typescript
    // ‚è© RESOLUTION FINISHED: Start New Round
    if (resolvingUntil > 0 && now > resolvingUntil) {
        console.log(`[DiceDuel] ‚è© New Round in Room ${roomId}`);
        const nextRound = (room.currentRound || 1) + 1;
        
        // üö® FIX TIMER: Sumamos 5s. 4s de cartel + 1s de buffer.
        // El cliente ver√° el reloj clavado en 30s al terminar la animaci√≥n.
        const futureStart = Date.now() + 5000; 

        const updated = await prisma.room.update({
            where: { id: roomId },
            data: {
                currentRound: nextRound,
                gameMeta: {
                    ...meta,
                    rolls: {},
                    lastDice: meta.lastDice, 
                    roundResolvingUntil: 0,
                    roundStartedAt: futureStart, // <--- 5 SEGUNDOS AL FUTURO
                    history: meta.history
                } as any
            },
            include: { entries: { include: { user: true } } }
        });
        await emitRoomUpdate(roomId);
        return updated;
    }
```

**Bloque de Gesti√≥n de Bots (Buscar y reemplazar):**

```typescript
    /* SCENARIO A: BOT MANAGEMENT (Strict Shadow Logic) */
    
    // 1. üßπ KICK LONELY BOT: Si P1 es bot y no hay P2, eliminarlo.
    if (p1 && !p2 && p1.user.isBot) {
        console.log(`[DiceDuel] üßπ Kicking lonely bot ${p1.user.name}`);
        await prisma.entry.delete({ where: { id: p1.id } });
        const cleaned = await prisma.room.update({
            where: { id: roomId },
            data: { state: "OPEN", autoLockAt: null, gameMeta: {} as any },
            include: { entries: { include: { user: true } } }
        });
        await emitRoomUpdate(roomId);
        return cleaned;
    }

    // 2. ü§ñ ADD BOT: Solo si hay HUMANO esperando y pas√≥ el tiempo
    if (p1 && !p2 && freshRoom.autoLockAt && now > freshRoom.autoLockAt.getTime()) {
        if (p1.user.isBot) return freshRoom; // Si el que espera es bot, no hacer nada

        // Verificar que pasaron 5s desde el √∫ltimo update para no ser intrusivo
        const lastUpd = new Date(freshRoom.updatedAt).getTime();
        if (now - lastUpd < 5000) return freshRoom;

        let botUser = await prisma.user.findFirst({
            where: { 
                isBot: true,
                entries: { none: { room: { state: { in: ["OPEN", "LOCKED"] } } } }
            },
            orderBy: { updatedAt: 'asc' }
        });

        if (botUser) {
            await prisma.entry.create({
                data: { roomId, userId: botUser.id, position: 2, round: freshRoom.currentRound ?? 1 }
            });
            balances[botUser.id] = freshRoom.priceCents;
            
            const updated = await prisma.room.update({
                where: { id: roomId },
                data: {
                    autoLockAt: null,
                    state: "LOCKED",
                    gameMeta: {
                        ...meta,
                        balances,
                        roundStartedAt: Date.now() + 2000, // <--- 2s de cortes√≠a para "sentarse"
                        autoPlay: false
                    } as any
                },
                include: { entries: { include: { user: true } } }
            });
            await emitRoomUpdate(roomId);
            return updated;
        }
    }
```

### 3\. `src/modules/games/dice/components/dice/DiceBoard.tsx` (L√≥gica Blindada)

Reemplaza el componente `DiceBoard` completo.
**Puntos clave del nuevo c√≥digo:**

1.  `animationLock`: Congela la UI durante 4s cuando hay ganador.
2.  `getSafeSkin`: Evita que el bot robe tu color.
3.  `Math.min(30, ...)`: Recorta el tiempo "extra" que manda el servidor para que siempre empiece en 30s.

<!-- end list -->

```tsx
"use client";
import { useEffect, useMemo, useRef, useState } from "react";
import { useRouter } from "next/navigation";
import DiceDuel from "@/modules/games/dice/components/DiceDuel";
import { type DiceSkin } from "./ThreeDDice";
import { toast } from "sonner";
import confetti from "canvas-confetti";
import { useAudio } from "@/context/AudioContext";

// ... (Copiar types Entry y Room de tu c√≥digo actual)

const fmtUSD = (c: number) => `$${(c / 100).toFixed(2)}`;
function toSkin(s?: string | null): DiceSkin {
  const allowed = ["white", "green", "blue", "yellow", "red", "purple", "black"];
  return (s && allowed.includes(s)) ? (s as DiceSkin) : "white";
}

export default function DiceBoard({ room, userId, email, onLeave, onRejoin, onOpenHistory, wheelSize }: any) {
  const router = useRouter();
  const { play } = useAudio();
  
  // 1. POSICI√ìN PERSISTENTE
  const persistentPos = useRef<number | null>(null);
  const meEntry = room.entries?.find((e:any) => e.user.id === userId || (email && e.user.email === email));
  if (meEntry && persistentPos.current === null) persistentPos.current = meEntry.position;
  
  const amTop = persistentPos.current === 1;
  const swapVisuals = amTop; // P1 siempre se ve abajo

  const topEntry = room.entries?.find((e:any) => e.position === 1);
  const bottomEntry = room.entries?.find((e:any) => e.position === 2);

  // 2. ESTADO
  const [visualWinner, setVisualWinner] = useState<any>(null);
  const [animationLock, setAnimationLock] = useState(false);
  const [rolling, setRolling] = useState(false);
  const [timer, setTimer] = useState(30);

  // 3. DETECTAR GANADOR (Server)
  const serverWinner = useMemo(() => {
    const history = room.gameMeta?.history || [];
    if (!history.length) return null;
    const last = history[history.length - 1];
    return {
        name: !last.winnerEntryId ? "Empate" : (room.entries?.find((e:any) => e.id === last.winnerEntryId)?.user?.name || "Jugador"),
        amount: fmtUSD(last.damage ?? 0),
        isTie: !last.winnerEntryId,
        round: last.round
    };
  }, [room.gameMeta?.history]);

  // 4. SINCRONIZACI√ìN DE ANIMACI√ìN
  const lastRound = useRef(0);
  useEffect(() => {
    if (serverWinner && serverWinner.round !== lastRound.current) {
        lastRound.current = serverWinner.round;
        setAnimationLock(true);
        // 1.5s rodar -> 4s cartel -> Unlock
        setTimeout(() => {
            setVisualWinner(serverWinner);
            if (room.state === "FINISHED") play("win");
            setTimeout(() => {
                setVisualWinner(null);
                setAnimationLock(false);
                router.refresh();
            }, 4000);
        }, 1500);
    }
  }, [serverWinner]);

  // 5. TIMER REFORZADO
  const roundStartedAt = (room.gameMeta?.roundStartedAt as number) || 0;
  useEffect(() => {
    if (animationLock) return;
    const tick = () => {
         if (!roundStartedAt) { setTimer(30); return; }
         const elapsed = (Date.now() - roundStartedAt) / 1000;
         // El servidor manda tiempo futuro (+2s o +5s). Math.min lo clava en 30.
         setTimer(Math.max(0, Math.min(30, Math.floor(30 - elapsed))));
    };
    tick();
    const t = setInterval(tick, 1000);
    return () => clearInterval(t);
  }, [roundStartedAt, animationLock]);

  // 6. SKINS SEGURAS (Bot no roba color)
  const getSkin = (e?: any) => {
      if (!e) return "white";
      if (e.user.isBot) return "red"; // Bot siempre rojo (ejemplo)
      return toSkin(e.user.selectedDiceColor);
  }
  const topSkin = getSkin(topEntry);
  const bottomSkin = getSkin(bottomEntry);

  // 7. RENDER
  const rolls = room.gameMeta?.rolls || {};
  const lastDice = room.gameMeta?.lastDice || {};
  
  // Si hay lock, mostrar lastDice. Si no, rolls actuales.
  const dTop = animationLock ? lastDice.top : (rolls[topEntry?.user.id] || lastDice.top);
  const dBot = animationLock ? lastDice.bottom : (rolls[bottomEntry?.user.id] || lastDice.bottom);

  const handleRoll = async () => {
    if (rolling || animationLock) return;
    setRolling(true); play("roll");
    try { await fetch(`/api/rooms/${room.id}/roll`, { method: "POST" }); router.refresh(); } 
    finally { setTimeout(() => setRolling(false), 500); }
  };

  let statusText = animationLock ? "" : (meEntry ? "¬°TU TURNO!" : "Esperando...");
  
  // Heartbeat
  useEffect(() => {
     if (!animationLock && room.state === "OPEN") {
         const t = setInterval(() => router.refresh(), 3000);
         return () => clearInterval(t);
     }
  }, [animationLock, room.state]);

  return (
    <div className="relative flex flex-col items-center">
      <div className="w-full mx-auto relative" style={{ maxWidth: wheelSize }}>
        <DiceDuel
          topRoll={swapVisuals ? dBot : dTop}
          bottomRoll={swapVisuals ? dTop : dBot}
          isRollingBottom={swapVisuals ? false : rolling} // Simplificado
          statusText={statusText}
          winnerDisplay={visualWinner}
          onRoll={handleRoll}
          canRoll={!rolling && !animationLock} // Agregar validaci√≥n de turno real aqu√≠
          timeLeft={!animationLock ? timer : undefined}
          labelTop={swapVisuals ? (bottomEntry?.user.name || "J2") : (topEntry?.user.name || "J1")}
          labelBottom="T√∫"
          diceColorTop={swapVisuals ? bottomSkin : topSkin}
          diceColorBottom={swapVisuals ? topSkin : bottomSkin}
          // ... resto de props
          onExit={onLeave} onRejoin={onRejoin} isFinished={room.state === "FINISHED"}
        />
      </div>
    </div>
  );
}
```

### 4\. `src/app/api/rooms/[id]/roll/route.ts` (Bot Humano)

En el bloque del bot, aumenta el delay para humanizarlo.

```typescript
// ...
if (opponentIsBot && !currentRolls[opponentEntry.userId]) {
    // Delay aleatorio entre 2.5s y 4.5s
    const humanDelay = Math.floor(Math.random() * 2000) + 2500;
    await new Promise(r => setTimeout(r, humanDelay));
    // ... roll logic ...
}
```

### 5\. `src/modules/rooms/components/BuySeatUI.tsx` (Popup Fix)

Agrega al inicio:

```typescript
if (room.state !== "OPEN" || room.entries.length >= 2) return null;
```