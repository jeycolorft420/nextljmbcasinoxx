Entendido. Vamos a elevar la calidad de tu juego de dados a un nivel profesional y corregir la l贸gica de los bots para que se comporten como usuarios reales (sin clonarse y sin jugar solos).

Aqu铆 tienes las instrucciones t茅cnicas precisas para **Gravity**.

-----

### 1\.  L贸gica de Bots: "Cerebro nico" y "Anti-Soledad"

**Problema:** El sistema eleg铆a el primer bot que encontraba, permitiendo que el mismo "JuanBot" jugara en 5 salas a la vez. Adem谩s, se quedaban solos si el humano se iba.
**Soluci贸n:** Modificar la consulta a la base de datos para buscar solo bots **desocupados** y agregar una limpieza autom谩tica.

**Archivo:** `src/modules/games/dice/lib/maintenance.ts`

**Instrucci贸n para Gravity:**

> "Reemplaza completamente el bloque `/* SCENARIO A: ADD BOT */` en `maintenanceDiceDuel` con esta l贸gica mejorada.
>
> **Cambios clave:**
>
> 1.  El `findFirst` ahora excluye bots que ya est谩n jugando en salas activas (`entries: { none: ... }`).
> 2.  Se agrega una validaci贸n al inicio: Si hay un jugador y es un Bot (y est谩 solo), se elimina de la sala para que no juegue solo."

**C贸digo para `maintenance.ts`:**

```typescript
    /* -------------------------------------------------------------------------- */
    /* SCENARIO A: BOT MANAGEMENT (Uniqueness & Cleanup)                     */
    /* -------------------------------------------------------------------------- */
    
    // 1. ANTI-LONELINESS: Si solo hay 1 jugador y es un BOT, sacarlo.
    if (p1 && !p2) {
        const userP1 = await prisma.user.findUnique({ where: { id: p1.userId } });
        if (userP1?.isBot) {
            console.log(`[DiceDuel] Ч Removing lonely bot ${userP1.name} from room ${roomId}`);
            await prisma.entry.delete({ where: { id: p1.id } });
            // Devolvemos la sala a estado OPEN limpio
            const cleaned = await prisma.room.update({
                where: { id: roomId },
                data: { state: "OPEN", autoLockAt: null, gameMeta: {} as any },
                include: { entries: { include: { user: true } } }
            });
            await emitRoomUpdate(roomId);
            return cleaned;
        }
    }

    // 2. ADD BOT (Smart Selection)
    if (!p2 && freshRoom.autoLockAt && new Date() > freshRoom.autoLockAt) {
        console.log(`[DiceMaintenance] Timer Expired. Looking for available bot...`);

        // Buscamos un bot que NO est茅 jugando actualmente
        let botUser = await prisma.user.findFirst({
            where: { 
                isBot: true,
                // CRTICO: Asegurar que no est茅 en otra sala activa
                entries: {
                    none: {
                        room: {
                            state: { in: ["OPEN", "LOCKED"] }
                        }
                    }
                }
            },
            orderBy: { createdAt: 'desc' } // O 'updatedAt' para rotaci贸n
        });

        if (botUser) {
            console.log(`[DiceDuel]  Adding Bot: ${botUser.name} to Room ${roomId}`);
            await prisma.entry.create({
                data: {
                    roomId,
                    userId: botUser.id,
                    position: 2,
                    round: freshRoom.currentRound ?? 1
                }
            });

            balances[botUser.id] = freshRoom.priceCents;

            const updated = await prisma.room.update({
                where: { id: roomId },
                data: {
                    autoLockAt: null,
                    gameMeta: {
                        ...meta,
                        balances,
                        roundStartedAt: Date.now(),
                        autoPlay: false
                    } as any
                },
                include: { entries: { include: { user: true } } }
            });
            await emitRoomUpdate(roomId);
            return updated;
        } else {
            console.log("[DiceDuel] 锔 No available bots found (all busy).");
        }
    }
```

-----

### 2\.  Animaciones: De "B谩sico" a "Casino 3D Real"

**Problema:** La animaci贸n actual es r铆gida.
**Soluci贸n:** Implementar keyframes CSS complejos que simulen una f铆sica de "tumbling" (giro en 3 ejes) y desenfoque de movimiento (motion blur).

**Paso A: Actualizar el CSS**
**Archivo:** `src/modules/games/dice/components/dice/ThreeDDice.css`

**Instrucci贸n para Gravity:**

> "Reemplaza todo el contenido de `ThreeDDice.css` con este estilo avanzado. Incluye desenfoque y rotaci贸n en 3 ejes."

```css
.scene {
  width: 100%;
  height: 100%;
  perspective: 600px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.cube {
  width: 100%;
  height: 100%;
  position: relative;
  transform-style: preserve-3d;
  transition: transform 0.8s cubic-bezier(0.1, 0.9, 0.2, 1); /* Suavizado "landing" */
}

.cube__face {
  position: absolute;
  width: 100%;
  height: 100%;
  border-radius: 14%; /* Bordes m谩s realistas */
  border: 1px solid rgba(0,0,0,0.1);
  background: white; /* Fallback */
  box-shadow: inset 0 0 15px rgba(0,0,0,0.15); /* Profundidad interna */
  backface-visibility: hidden; /* Optimizaci贸n */
}

/* Posiciones de las caras */
.cube__face--1 { transform: rotateY(0deg) translateZ(var(--depth)); }
.cube__face--2 { transform: rotateY(90deg) translateZ(var(--depth)); }
.cube__face--3 { transform: rotateY(180deg) translateZ(var(--depth)); }
.cube__face--4 { transform: rotateY(-90deg) translateZ(var(--depth)); }
.cube__face--5 { transform: rotateX(90deg) translateZ(var(--depth)); }
.cube__face--6 { transform: rotateX(-90deg) translateZ(var(--depth)); }

/* ANIMACIN ULTRA-REALISTA */
@keyframes tumble {
  0% { transform: rotateX(0) rotateY(0) rotateZ(0); }
  25% { transform: rotateX(180deg) rotateY(90deg) rotateZ(45deg); }
  50% { transform: rotateX(360deg) rotateY(180deg) rotateZ(90deg); }
  75% { transform: rotateX(540deg) rotateY(270deg) rotateZ(135deg); }
  100% { transform: rotateX(720deg) rotateY(360deg) rotateZ(360deg); }
}

.is-rolling {
  animation: tumble 0.6s linear infinite;
  filter: blur(1px); /* Motion Blur */
}
```

**Paso B: Actualizar el Componente (Para conectar el CSS)**
**Archivo:** `src/modules/games/dice/components/dice/ThreeDDice.tsx`

**Instrucci贸n para Gravity:**

> "Actualiza el componente `ThreeDDice` para usar variables CSS din谩micas para el tama帽o (`--depth`). Esto asegura que el cubo se vea perfecto en m贸viles y escritorio."

```tsx
// Dentro de ThreeDDice.tsx

// ... imports ...

export const ThreeDDice = ({ face, rolling, skin, size = 100, variant = 1 }: Props) => {
  // Calcular la profundidad (mitad del tama帽o) para el CSS
  const style = { 
    width: size, 
    height: size, 
    "--depth": `${size / 2}px` 
  } as React.CSSProperties;

  // Mapa de rotaciones para que el resultado siempre mire al frente
  const getTransform = (val: number) => {
    switch(val) {
      case 1: return 'rotateY(0deg)';
      case 2: return 'rotateY(-90deg)';
      case 3: return 'rotateY(180deg)';
      case 4: return 'rotateY(90deg)';
      case 5: return 'rotateX(-90deg)';
      case 6: return 'rotateX(90deg)';
      default: return 'rotateY(0deg)';
    }
  };

  // Si est谩 rodando, quitamos la transformaci贸n fija para que el CSS tome el control
  const transform = rolling ? undefined : getTransform(face || 1);

  return (
    <div className="scene" style={{ width: size, height: size }}>
      <div 
        className={`cube ${rolling ? "is-rolling" : ""}`} 
        style={{ ...style, transform }}
      >
        {[1, 2, 3, 4, 5, 6].map((n) => (
           // Renderiza las im谩genes de las caras (tu c贸digo existente de im谩genes va aqu铆)
           <div key={n} className={`cube__face cube__face--${n}`}>
              {/* <Image ... tu l贸gica de skins actual ... /> */}
              {/* Aseg煤rate de mantener tu l贸gica de selecci贸n de imagen aqu铆 */}
              <img src={`/dice/${skin}/${n}.png`} alt={`Face ${n}`} className="w-full h-full object-cover rounded-[14%]" />
           </div>
        ))}
      </div>
    </div>
  );
};
```

*(Nota: Aseg煤rate de adaptar la etiqueta `<img>` o `<Image>` a como la ten铆as en tu c贸digo original para que cargue tus texturas, pero mant茅n las clases `cube__face`).*

-----

### 3\.  Fix "Popup Molesto" (Comprar Puestos)

**Problema:** El popup sale durante la partida porque el frontend a veces pierde el estado del usuario.
**Soluci贸n:** Ocultar estrictamente el bot贸n/popup si la partida ya comenz贸 (`state !== OPEN`), independientemente de si el usuario est谩 logueado o no.

**Archivo:** `src/modules/rooms/components/BuySeatUI.tsx` (o donde est茅 el bot贸n, posiblemente `DiceBoard.tsx` si est谩 integrado all铆, pero revisando tus archivos, parece que la l贸gica est谩 en `DiceDuel.tsx` o `BuySeatUI`).

**Instrucci贸n para Gravity:**

> "En el componente que muestra el bot贸n de 'Comprar Puesto' (probablemente `BuySeatUI` o la secci贸n de entrada en `page.tsx`), agrega esta condici贸n de seguridad:
>
> ```tsx
> if (room.state !== "OPEN") return null;
> ```
>
> Esto evitar谩 que el popup aparezca cuando la ronda ya est谩 girando o resolvi茅ndose, incluso si hay un error moment谩neo de carga de datos."

**Y para `DiceBoard.tsx` (L贸gica de estado):**

> "En `DiceBoard.tsx`, aseg煤rate de que `isResolving` o `rolling` bloqueen cualquier intento de mostrar modales de compra."